---
layout: post
title: "Enterprise Crossword Solving"
date: 2024-09-27 14:00:00 +0100
categories: process
excerpt_separator: <!--more-->
---

Software development is an almost uniquely enigmatic field for people who are not software developers. We type weird words onto screens and it'll make pixels on the screen of someone we'll never meet move around. Very little of what we produce can be touched or handled, handed to a friend around a dinner table, unless you're lucky enough to work on firmware. So when we talk about feeling burned out or frustrated with our jobs, it can be hard for people on the outside to understand - especially when we'll seemingly talk endlessly and passionately about what sounds like the same thing.

So I want you to imagine you're solving a crossword. At scale.

<!--more-->

## Solving Crosswords at Scale

You are part of a crossword-solving team, where you try and solve crosswords fast enough to win a prize from the publisher. There are a dozen of you who are designated "clue solvers" - your job is to be given a clue from the puzzle, solve it, then add it to the crossword. In order to help keep everyone organised, there are a trio of "word checkers", who will check your solution is in the official dictionary used by the publisher. There is also someone who decides which clues should be given to which solver, and another who is responsible for making sure all the solutions fit together.

You're given the clue "A large mammal that is commonly found in wooded environments". You know the word is 4 letters long, and the first letter of the word is a `B` because someone already solved that square earlier in the week. It takes you about five minutes to decide the answer is `BEAR`. The team process dictates that you need to have another solver check your word, before you send it on to the checkers.

Sending the word over to the other solver - they immediately reply saying they can't sign off on it, because surely the answer is `BIRD`. It would have too much to send the whole clue along at the beginning and expect them to solve it too, so you then explain that a bird isn't a mammal, which is a requirement. They take 2 days to get back to you about confirming that a bird isn't a mammal, during which you've spent most of your time double checking that a bird is, in fact, not a mammal. They confirm that `BEAR` could be a valid solution, but aren't *personally* convinced for reasons they can't fully articulate - and might just be because you annoyed them by not immediately accepting their `BIRD` answer.

Now you've had the solution stamped, you take it over to the checkers. There's already a stack of solutions from other solvers on their desk - annoyingly, including a word from the solver who just made you wait 2 days to get a stamp. You add yours to the pile, with the position marker `13 ACROSS`. Somehow you've not even made it back to your desk before an irate message awaits you, simply reading "`BARE` isn't an animal, and normal people don't get naked in the woods". It takes you half a day to untangle the miscommunication, where the checker team have a process of reading words out to one another in order to look them up in a dictionary faster. Finally, it's approved, and you're able to take it from the checkers to the two people overseeing the crossword.

On handing off the completed word, the head solver questions why you didn't use the word `BOAR` - they make a last minute executive decision to write that instead. You don't have time to worry about this though, as the team organiser has given you your next clue to work on - `27 DOWN`. You get back to your desk to look up the clue itself, in time to receive a message that your work on `13 ACROSS` didn't work, because it turns out that the word should start with a `D` not a `B` - because the word that gave you that starting letter was also wrong. You're already reassigned to your new task however, so the work on figuring out which four-letter forest dweller starts with a `D` is going to fall on someone else.

The crossword is solved by two teenagers in kansas, who sit down together for a pleasant afternoon with a dictionary and rattle through the whole thing. They win the Â£100 prize, while your innovative puzzle-solving organisation folds 18 months later without winning a single contest.

## The Misguided Desire to Simplify Problems

I feel like this approach to breaking down software development problems comes from treating the process like an assembly line. In a traditional assembly line the more you break down the problem (starting from "Build a car"), the more you can find micro-optimisations in pieces of the process, the more cars you're going to get built. The problem in software is that as you extract individual problems away from the whole, it often becomes harder - not easier - to reason about them. Much like a crossword the surrounding structure of an application will inform the minute-to-minute decisions you make on how the specific piece of functionality you're working on should be built. This is then compounded by introducing layers of communication that aren't centered around the functioning application itself - rather the written code on a webpage, or some piece of specification in a ticketing system.

It would be easy here to just paint this with a brush of "well, agile failed, we should go back to waterfall" - but the thing is, nothing about agile demands the breaking down of problems at all. Seriously, go read the [principles](https://agilemanifesto.org/principles.html), I'll wait. The closest demand it makes is "Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale." - the thing is, you can deliver working software all the time as you change it, even if you haven't entirely solved the problem yet. To go back to the crossword analogy, there's nothing stopping you from continually showing the puzzle as you fill in the words - and at a certain point, someone might decide you've solved "enough" of the puzzle for them to be happy.

This is where I get a bit radical in my suggestions of what *did* happen. A bunch of not-software-developers co-opted the language of agile (which to me, is a bottom-up movement for developers) while filling it with management processes and false notions of "scaling". The problem is that as you try and "manage" your way to solving the puzzle, you're essentially creating layers on layers of plans - the very thing we're supposed to be avoiding. Instead all you end up doing is obfuscating the true puzzle from the very people you've employed to solve it, while simultaneously removing their agency to get on and solve said puzzle.

## But What Can I Do?

I'll start with talking to anyone who is reading this, who isn't a software developer, and hasn't closed the webpage already because I've accidentally insulted you. I am begging you. Genuinely *begging you*. Start giving the whole problem to developers - either individually, or in *very* small groups of 2-3. More business value has been shipped faster (with less issues) when part of small, highly focused teams who are given the problem to solve and a deadline to hit. It would be mad to pretend that this is a perfect way of working, and that all software developers are capable of it from the jump. But for a role that is supposed to be skilled and "subject matter expert" focused, businesses just can't seem to help hiring a glut of developers and giving them tiny things to work on. In any other field equivalent jobs would be given in their totality - "Go win that contract", "go put together that pitch deck", "build out next year's marketing strategy" - yet it feels like larger organisations want to give developers the equivalent of "Can you make slide 17 of the pitch deck?"

For me, scaling a development team doesn't mean you necessarily get things done faster, or better - but it allows you to make more bets. When individuals and small teams are trusted with an entire problem, it means that other (entire) problems can be given to others. Suddenly you're not having to fight upstream against conflicts between teams or situations where one micro-problem is trying to take priority over another. This is a little bit of a weaponisation of [Conway's Law](https://en.wikipedia.org/wiki/Conway%27s_law) - if you just let the teams own a part of the system, it's engineering will naturally fit the existing communication structures of the organisation.

Now for the tough love moment for the developers still reading this. There are two things you need to do - the first is to get your head the hell out of Jira (feel free to replace with the bane of your existence here). The big mental shift for me was stopping seeing Jira as my work - rather, it's a way I can communicate about my work to the business. It's the same reason I rally hard against things like tickets for refactoring or writing tests - that isn't work you should be being told to do, that's just your job! It's like a woodworker waiting to be told to put all his tools away and sweep his benches, or a plumber not turning off the water unless the client asks him to. Sure, you *could* get away with not doing these things - and sometimes you might even need to - but if you're just wanting to leave it for someone else to do later, that just makes you a bit of an arse to the next person.

The second thing is to figure out what your business, your bosses and your customers actually care about - and then work on building that. Good software development involves drowning yourself in the domain in which your application lives, and growing an appreciation for the system and the people wanting it built. This isn't the same as going totally rogue and doing whatever you feel like - instead, it's about trying to move your problem solving for the business "up a level". To call back to the crossword analogy - it's like at least having a go at solving the clues that connect to your "main" clue, even if no one is *explicitly* telling you to do this. As a consequence you'll be shifting your thinking from "how do I solve this clue" to "how do I solve this part of the crossword" - and the second is way more impactful. When I look back over my career, the truth is that the work that was out on a limb, trying to get ahead of the *next* problem, to solve the *full business need*, essentially never got rejected. This isn't because I'm a genius, or some "10x-er" - it's because I wanted to solve the problem of the person signing my paychecks, or the people paying that person, rather than getting bogged down into specific tasks assigned to me.

For further reading, give the fantastic essay ["Programming Sucks"](https://www.stilldrinking.org/programming-sucks) a go. It's another take on this issue, focused on malaise around the actual job of coding itself, and if nothing else is dead funny. If you want something else written by me in the same vein as this, ["Not My Job"]({% post_url 2020-07-19-not-my-job %}) which I wrote way back in 2020 remains relevant.